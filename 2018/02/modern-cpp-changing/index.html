<!DOCTYPE html>
<html lang="zh-tw">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.62.2 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="Cheng-Shiang Li">
<meta name="keywords" content="">
<meta name="description" content="Modern C&#43;&#43; changing">


<meta property="og:description" content="Modern C&#43;&#43; changing">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern C&#43;&#43; changing">
<meta name="twitter:title" content="Modern C&#43;&#43; changing">
<meta property="og:url" content="/2018/02/modern-cpp-changing/">
<meta property="twitter:url" content="/2018/02/modern-cpp-changing/">
<meta property="og:site_name" content="Xeno Universe - The Dark Forest">
<meta property="og:description" content="Modern C&#43;&#43; changing">
<meta name="twitter:description" content="Modern C&#43;&#43; changing">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2018-02-03T16:00:00">
  
  
    <meta property="article:modified_time" content="2018-02-03T16:00:00">
  
  
  
    
      <meta property="article:section" content="Programming">
    
  
  
    
      <meta property="article:tag" content="C&#43;&#43;">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="/images/about/me.jpg">
  <meta property="twitter:image" content="/images/about/me.jpg">


    <title>Modern C&#43;&#43; changing</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="/2018/02/modern-cpp-changing/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="/css/style-tranquilpeak.css">
      
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-104710641-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/">Xeno Universe - The Dark Forest</a>
  </div>
  
    
      <a class="header-right-picture "
         href="/#about">
    
    
    
      
        <img class="header-picture" src="/images/about/me.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about">
          <img class="sidebar-profile-picture" src="/images/about/me.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Cheng-Shiang Li</h4>
        
          <h5 class="sidebar-profile-bio">Senior software developer. Mastering Android/iOS application development and machine learning algorithm.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/about/">
    
      
      
      <span class="sidebar-button-desc">About Me</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yeshuanova">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.linkedin.com/in/cheng-shiang-li">
    
      <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
      
      <span class="sidebar-button-desc">Linkedin</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="mailto:yeshuanova@gmail.com" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg  fa-envelope-o"></i>
      
      <span class="sidebar-button-desc">Email</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Modern C&#43;&#43; changing
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-02-03T16:00:00&#43;08:00">
        
  February 3, 2018

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="/categories/programming">Programming</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>C++ 標準自從建立後到現在已經經過了許多次改版，其中最重要的版本除了 C++98 外，當在2011 年正式發佈的 C++11 標準了。該標準加入了許多新特性，不但讓程式撰寫更為精簡，在執行時效率也更加上升，可說是之後 C++14 與 C++17 等標準的基石。本篇文章簡單整理了一些關於 C++11 重要標準變更與概念，若要詳細了解相關內容以及 C++14/17 的相關變更可參考 <a href="https://en.wikipedia.org/wiki/C%2B%2B11">Wikipedia</a> 等網站。</p>

<h2 id="語法變更">語法變更</h2>

<h4 id="auto-and-decltype">Auto and decltype</h4>

<p>C++11 可使用 <code>Auto</code> 來自動推導宣告的變數型別，藉以減少需要撰寫的資料長度。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#00cd00">float</span> x <span style="color:#39c">=</span> <span style="color:#cd00cd">3.0f</span>;
vector<span style="color:#39c">&lt;</span>string<span style="color:#39c">&gt;</span> vec <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span>string<span style="color:#39c">&gt;</span>();

<span style="color:#000080">// C++11, 自動型別推導
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> x_11 <span style="color:#39c">=</span> <span style="color:#cd00cd">3.0f</span>;   <span style="color:#000080">// x_11 is float type
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> vec_11 <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span>std<span style="color:#39c">:</span><span style="color:#39c">:</span>string<span style="color:#39c">&gt;</span>();
</code></pre></div>
<p>而關鍵字 <code>decltype</code> 可由已存在變數的推導出型別</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00cd00">float</span> f <span style="color:#39c">=</span> <span style="color:#cd00cd">30.0f</span>;
<span style="color:#cdcd00">decltype</span>(f) fc; <span style="color:#000080">// variable &#39;fc&#39; is float type
</span></code></pre></div>
<p>實作上 <code>decltype</code> 常與 <code>auto</code> 並用，如自動推導 template function 的返回型別等。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Fun</span>, <span style="color:#cdcd00">class</span><span style="">.</span><span style="">.</span><span style="">.</span><span style=""> </span><span style="color:#00cdcd">Args</span><span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">decltype</span>(<span style="color:#cdcd00">auto</span>) Example(Fun fun, Args<span style="color:#39c">&amp;</span><span style="color:#39c">&amp;</span>... args)
{
    <span style="color:#cdcd00">return</span> fun(std<span style="color:#39c">:</span><span style="color:#39c">:</span>forward<span style="color:#39c">&lt;</span>Args<span style="color:#39c">&gt;</span>(args)...);
}
</code></pre></div>
<h4 id="constexpr">Constexpr</h4>

<p>C++11 可透過 constexpr 來限制 function 行為，讓編譯器可以在編譯時提早決定數值。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span> T<span style="color:#39c">&gt;</span> <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">K</span> {};

<span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> getValue(<span style="color:#00cd00">int</span> x) { <span style="color:#cdcd00">return</span> x <span style="color:#39c">+</span> <span style="color:#cd00cd">5</span>;}
<span style="color:#cdcd00">auto</span> ss <span style="color:#39c">=</span> K<span style="color:#39c">&lt;</span>getValue(<span style="color:#cd00cd">3</span>)<span style="color:#39c">&gt;</span>(); <span style="color:#000080">// Compiler error !
</span><span style="color:#000080"></span>
<span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#cdcd00">constexpr</span> <span style="color:#00cd00">int</span> getValue(<span style="color:#00cd00">int</span> x) { <span style="color:#cdcd00">return</span> x <span style="color:#39c">+</span> <span style="color:#cd00cd">5</span>;}
<span style="color:#cdcd00">auto</span> ss <span style="color:#39c">=</span> K<span style="color:#39c">&lt;</span>getValue(<span style="color:#cd00cd">3</span>)<span style="color:#39c">&gt;</span>(); <span style="color:#000080">// pass !!
</span></code></pre></div>
<h4 id="null-pointer-constant">Null pointer constant</h4>

<p>過去 C++ 標準並沒有定義空指標的代表關鍵字，而常用的 <code>NULL</code> 表示式也常常只是使用 macro 將 NULL 定義為 <code>0</code> 而已，因此 C++11 在標準中加入了 <code>nullptr</code> 關鍵字來定義空指標。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span><span style="color:#39c">*</span> p03 <span style="color:#39c">=</span> <span style="color:#cd00cd">NULL</span>;

<span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span><span style="color:#39c">*</span> p11 <span style="color:#39c">=</span> <span style="color:#cdcd00">nullptr</span>
</code></pre></div>
<h4 id="rangebased-for-loop">Range-based for loop</h4>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">auto</span> vec <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>{<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>, <span style="color:#cd00cd">4</span>, <span style="color:#cd00cd">5</span>};
<span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#cdcd00">for</span> (<span style="color:#00cd00">int</span> i <span style="color:#39c">=</span> <span style="color:#cd00cd">0</span>; i <span style="color:#39c">&lt;</span> <span style="color:#cd00cd">5</span>; <span style="color:#39c">+</span><span style="color:#39c">+</span>i) {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> array[i] <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}
<span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#cdcd00">for</span> (<span style="color:#cdcd00">auto</span><span style="color:#39c">&amp;</span> r: vec) {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> r <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}
</code></pre></div>
<h4 id="initializer-lists-and-uniform-initialization">Initializer lists and uniform initialization</h4>

<p>在 C++03 中，如要對 vector 等物件進行初始化時需要另外執行 <code>push_back()</code> 動作。假如想建立一個內部包含 1 ~ 3 的整數數字的 <code>vecotor&lt;int&gt;</code>，需要如下範例建立 vec 物件</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span>vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span> vec <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>();
vec.push_back(<span style="color:#cd00cd">1</span>);
vec.push_back(<span style="color:#cd00cd">2</span>);
vec.push_back(<span style="color:#cd00cd">3</span>);
</code></pre></div>
<p>而在 C++11 中可利用 <code>std::initializer_list</code> ，並透過 <code>{}</code> 達成 uniform initialization。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++11, simple !
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> vec <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>{<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>};
</code></pre></div>
<p>若資料為嵌套的類型，也可用相同方式初始化</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">auto</span> vec_in <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span>vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span><span style="color:#39c">&gt;</span>{ {<span style="color:#cd00cd">1</span>}, {<span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>}, {<span style="color:#cd00cd">4</span>, <span style="color:#cd00cd">5</span>, <span style="color:#cd00cd">6</span>} };
<span style="color:#cdcd00">auto</span> pairs <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span>tuple<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span>, <span style="color:#00cd00">float</span><span style="color:#39c">&gt;</span><span style="color:#39c">&gt;</span>{ {<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">1.1f</span>}, {<span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">2.2f</span>}, {<span style="color:#cd00cd">3</span>, <span style="color:#cd00cd">3.3f</span>} };
</code></pre></div>
<h4 id="rvalue-reference-右值參照-與-move-semantic">R-Value Reference (右值參照) 與 Move Semantic</h4>

<p>在 C++ 的定義中，左值為可以透過記憶體參照對應到的物件，其他則為右值。也可以把右值想像成一個臨時的數值，左值可以被賦值並修改但右值不行。因 C++ 為值語意程式語言，在物件的建立上常會有多餘的建構與複製動作而倒置效能上的損失。而 C++11 中加入了右值參照功能，透過關鍵字 <code>&amp;&amp;</code> 來區別右值。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03, L-Value reference
</span><span style="color:#000080"></span><span style="color:#00cd00">void</span> ref(<span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span> x) {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">Left value: </span><span style="color:#cd0000">&#34;</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}

x <span style="color:#39c">=</span> <span style="color:#cd00cd">3</span>;
ref(x); <span style="color:#000080">// print: &#34;Left value: 3&#34;
</span><span style="color:#000080"></span>ref(<span style="color:#cd00cd">3</span>); <span style="color:#000080">// complier error !
</span><span style="color:#000080"></span>
<span style="color:#000080">// C++11, R-Value reference
</span><span style="color:#000080"></span><span style="color:#00cd00">void</span> ref(<span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span><span style="color:#39c">&amp;</span> x) {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">Right value</span><span style="color:#cd0000">&#34;</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}
x <span style="color:#39c">=</span> <span style="color:#cd00cd">3</span>;
ref(x); <span style="color:#000080">// print: &#34;Left value: 3&#34;
</span><span style="color:#000080"></span>ref(<span style="color:#cd00cd">3</span>); <span style="color:#000080">// print: &#34;Right value: 3&#34;
</span></code></pre></div>
<p>因可區別左值與右值，我們能使用右值參照達成  move semantic 的效果。右值可以想像成是個暫時的值，在達成任務後就會消失，那我們可以去將右值內部的資料直接<strong>移動</strong>到新物件中，避免過多的複製動作已增加程式效能。先定義一個簡單的<code>MoveVec</code> 結構</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">MoveVec</span> {
    std<span style="color:#39c">:</span><span style="color:#39c">:</span>vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span> vec;

    MoveVec() <span style="color:#39c">=</span> <span style="color:#cdcd00">default</span>;
    MoveVec(<span style="color:#cdcd00">const</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span><span style="color:#39c">&amp;</span> init)<span style="color:#39c">:</span> vec(init) {} <span style="color:#000080">// Copy constructor
</span><span style="color:#000080"></span>    MoveVec(vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span><span style="color:#39c">&amp;</span><span style="color:#39c">&amp;</span> init)<span style="color:#39c">:</span> vec(std<span style="color:#39c">:</span><span style="color:#39c">:</span>forward<span style="color:#39c">&lt;</span>vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span><span style="color:#39c">&gt;</span>(init)) {} <span style="color:#000080">// Move constructor
</span><span style="color:#000080"></span>};
</code></pre></div>
<p><code>MoveVec</code> 可使用一個 <code>vector&lt;int&gt;</code> 來初始化內部的 <code>vec</code> 物件。在 C++03 時需先在外部建立一個暫時的 <code>vector&lt;int&gt;</code> 物件，並使用它來初始化 <code>MoveVec</code> 時，會多出一次複製動作來將外部的 <code>vector&lt;int&gt;</code> 物件中的值複製到<code>MoveVec</code>中的<code>vec</code> 內部，無形中多增加了一次複製成本。在 C++11 可使用 move constoructor，將暫時物件的值移動到內部的<code>vector&lt;int&gt;</code> 資料中，避免多一次複製動作。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> vec_out <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>{<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>}; <span style="color:#000080">// Initial setting
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> obj <span style="color:#39c">=</span> MoveVec(vec_out); <span style="color:#000080">// Call copy constructor
</span><span style="color:#000080"></span>
<span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> obj_move <span style="color:#39c">=</span> MoveVec(vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>{<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>}); <span style="color:#000080">// Call move constructor
</span></code></pre></div>
<p>其中 <code>vec_out</code> 物件因為是左值，因此所呼叫的函式為 copy constructor 將物件內容複製到 <code>vec</code> 中。而建構 <code>obj_move</code> 物件時因傳入的參數為右值，因此會呼叫 move constructor  直接將傳入的 <code>vector&lt;int&gt;</code> 內部資源移動到<code>vec</code> 中，而不用在將所有資料複製一次。此外也可以使用的標準庫函式中的 <code>std::move</code> 函式，將左值物件強制轉換為右值參照以呼叫對應的函式。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">auto</span> obj_out <span style="color:#39c">=</span> MoveVec(std<span style="color:#39c">:</span><span style="color:#39c">:</span>move(vec_out)); 
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> vec_out.size(); <span style="color:#000080">// print: &#34;0&#34;，因 vec_out 的資料比被&#34;移動&#34;到 obj_out 中的 vec 內。
</span></code></pre></div>
<p>右值參照是 C++11 中加入的一個重要特徵，更詳細的內容可參考 <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors">Wikipedia</a> 的詳細介紹。</p>

<h4 id="lambda-functions-and-expressions">Lambda functions and expressions</h4>

<p>支援 Lambda expression 也是 C++11 中的一項重大修改。C++ 標準庫中有許多需要傳入計算式的運用，過去 C++ 需要另外創建函數才能執行，會造成撰寫 code 上的麻煩。而 C++11 支援 lambda expression，可直接創建匿名函式來執行需要的功能。現建立一個資料集</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">auto</span> vec <span style="color:#39c">=</span> vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>{<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>, <span style="color:#cd00cd">4</span>, <span style="color:#cd00cd">5</span>};
</code></pre></div>
<p>若要使用 <code>for_each</code> 對每個數值加ㄧ後輸出，C++03 中需要以下的方式執行</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#00cd00">void</span> plus(<span style="color:#00cd00">int</span> x) { cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">+</span> <span style="color:#cd00cd">1</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl; }
for_each(begin(vec), end(vec), plus());
</code></pre></div>
<p>由於需要另外撰寫函數或 <a href="http://www.bogotobogo.com/cplusplus/functors.php">Functor</a> ，無形中增加了實作上的麻煩，而 C++11 中的 lambda expression 可使用簡單撰寫匿名函式來傳入 <code>for_each</code> 中達成同樣的效果</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++11, Lambda expression
</span><span style="color:#000080"></span>for_each(begin(vec), end(vec), [](<span style="color:#cdcd00">auto</span><span style="color:#39c">&amp;</span> x){ cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">+</span> <span style="color:#cd00cd">1</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">,</span><span style="color:#cd0000">&#34;</span>; });
<span style="color:#000080">// print: 1,2,3
</span></code></pre></div>
<p>此外也可使用 <code>&amp;</code> 參數來引入外部參數</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00cd00">int</span> factor <span style="color:#39c">=</span> <span style="color:#cd00cd">42</span>;
std<span style="color:#39c">:</span><span style="color:#39c">:</span>for_each(begin(vec), end(vec), [<span style="color:#39c">&amp;</span>factor](<span style="color:#00cd00">int</span> x) { cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">+</span> factor <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">,</span><span style="color:#cd0000">&#34;</span>;});
<span style="color:#000080">// print: 43,44,45
</span></code></pre></div>
<h4 id="variadic-template">Variadic Template</h4>

<p><a href="https://en.wikipedia.org/wiki/Variadic_template">Variadic template</a> 也可翻<strong>可變參數模板</strong>，也是 C++11 中的一項重要變更。過去宣告 template  時參數數量需為固定，因此對於可變參數數量的結構就需要定義許多 template 結構。而在 C++11 中導入的 variadic template 可建立可變數量的參數結構，使用時可依照定義好的數量<strong>展開</strong>該結構。C++11 之後的可變參數 template 幾乎都使用了 variadic template 語法來接受可變數量參數。</p>

<p>Variadic template 基本宣告方式如下</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span>... Ts<span style="color:#39c">&gt;</span>
</code></pre></div>
<p>其中 <code>&lt;typename... Ts&gt;</code> 代表 <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">Parameter Pack</a> ，也就是一連串的參數列。以此<a href="https://eli.thegreenplace.net/2014/variadic-templates-in-c/">範例</a>來說</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> T<span style="color:#39c">&gt;</span>
T adder(T v) {
  <span style="color:#cdcd00">return</span> v;
}

<span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> T, <span style="color:#cdcd00">typename</span>... Ts<span style="color:#39c">&gt;</span>
T adder(T first, Ts... args) {
    <span style="color:#cdcd00">return</span> first <span style="color:#39c">+</span> adder(args...);
}
</code></pre></div>
<p>函式 <code>adder</code> 可接受不同長度的參數加總後回傳結果，下圖可為執行結果</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> adder(<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>); <span style="color:#000080">// output: 6  
</span><span style="color:#000080"></span>cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> adder(<span style="color:#cd00cd">4.2</span>, <span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">5</span>, <span style="color:#cd00cd">7.3</span>); <span style="color:#000080">// output: 19.5
</span><span style="color:#000080"></span>cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> adder(<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">1.3</span>); <span style="color:#000080">// output: 4
</span></code></pre></div>
<p>當 <code>adder(1, 2, 3)</code> 被呼叫時，編譯器會將 function 展開為如下的形式</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// adder(1, 2, 3) 呼叫的 funciton
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> adder(<span style="color:#00cd00">int</span> first, <span style="color:#00cd00">int</span> second, <span style="color:#00cd00">int</span> third) {
    <span style="color:#cdcd00">return</span> first <span style="color:#39c">+</span> adder(second, third);
}

<span style="color:#000080">// 上面函式中的 adder(second, third) 會再展開為下面型式
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> adder(<span style="color:#00cd00">int</span> first, <span style="color:#00cd00">int</span> second) {
    <span style="color:#cdcd00">return</span> first <span style="color:#39c">+</span> adder(second);
}

<span style="color:#000080">// 上面函示中的 add(second) 則會依照終止樣板展開為以下形式
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> adder(<span style="color:#00cd00">int</span> first) {
    <span style="color:#cdcd00">return</span> first;
}
</code></pre></div>
<p>因此當 <code>adder(1, 2, 3)</code> 被呼叫後，會將內容參數加總後回傳。且因為回傳型態跟呼叫的順序與參數內容有關，展開的 function 也會不同。如 <code>adder(4.2, 1, 2, 5, 7.3)</code> 因第一個數字是 <code>double</code> 型態，因此加總後會可正確回傳 double 型態數字 <strong>19.5</strong>，但如果呼叫 <code>adder(1, 2, 1.3)</code> 時因為最後一個回傳的型別是 <code>int</code>，因此小數點會被無條件捨去，因此只回傳 <strong>4</strong> 而不是 <strong>4.3</strong>。</p>

<p>除了 function 外，class 也可用相同的擴展方式建立 variadic template，如 <code>std::tuple</code> 就是一個例子，可建立一個內含不同參數的 tuple 結構，並透過 <code>std::get&lt;&gt;</code> 來取出內容，如下所示：</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// 建立一 tuple 結構
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> tp <span style="color:#39c">=</span> tuple<span style="color:#39c">&lt;</span>string, <span style="color:#00cd00">int</span>, vector<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span><span style="color:#39c">&gt;</span>(<span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">Hello</span><span style="color:#cd0000">&#34;</span>, <span style="color:#cd00cd">5</span>, {<span style="color:#cd00cd">42</span>, <span style="color:#cd00cd">2</span>});
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> get<span style="color:#39c">&lt;</span><span style="color:#cd00cd">0</span><span style="color:#39c">&gt;</span>(tp); <span style="color:#000080">// output: &#34;Hello&#34;
</span><span style="color:#000080"></span>cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> get<span style="color:#39c">&lt;</span><span style="color:#cd00cd">1</span><span style="color:#39c">&gt;</span>(tp); <span style="color:#000080">// output: 5
</span></code></pre></div>
<h4 id="explicit-overrides-and-final">Explicit overrides and final</h4>

<p>C++11 可透過關鍵字 <code>final</code> 顯示宣告來禁止 class 或 function 被 override</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// Class &#34;final&#34;
</span><span style="color:#000080"></span><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Base</span> <span style="color:#cdcd00">final</span> {};
<span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Derive</span><span style="color:#39c">:</span> Base {}; <span style="color:#000080">// compiler error!
</span><span style="color:#000080"></span>
<span style="color:#000080">// Funcion &#34;final&#34;
</span><span style="color:#000080"></span><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Base</span> {
    <span style="color:#cdcd00">virtual</span> <span style="color:#00cd00">void</span> show() <span style="color:#cdcd00">final</span>;
};

<span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Derive</span><span style="color:#39c">:</span> Base {
    <span style="color:#cdcd00">virtual</span> <span style="color:#00cd00">void</span> show(); <span style="color:#000080">// compiler error
</span><span style="color:#000080"></span>}
</code></pre></div>
<p>此外也可使用 <code>override</code> 關鍵字來明確定義該函式為 override function</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Base</span> {
    <span style="color:#cdcd00">virtual</span> <span style="color:#00cd00">void</span> show();
}

<span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Derive</span><span style="color:#39c">:</span> Base {
    <span style="color:#cdcd00">virtual</span> <span style="color:#00cd00">void</span> show2() <span style="color:#cdcd00">override</span>; <span style="color:#000080">// compiler error
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">virtual</span> <span style="color:#00cd00">void</span> show() <span style="color:#cdcd00">override</span>; <span style="color:#000080">// success
</span><span style="color:#000080"></span>}
</code></pre></div>
<h4 id="explicitly-defaulted-and-deleted-special-member-functions">Explicitly defaulted and deleted special member functions</h4>

<p>C++ 在類別建立時，自動建立如 default constructor, copy constructor 等預設函數，但有時候我們不希望該函數被建立，在過去需要宣告該函式為 private。而在 C++11 中支援了兩個關鍵字 <code>default</code> 與 <code>delete</code> 來控制預設建構式是否要建立。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Base</span> {
    Base() <span style="color:#39c">=</span> <span style="color:#cdcd00">default</span>; <span style="color:#000080">// default constructor 使用預設的行為
</span><span style="color:#000080"></span>    Base(<span style="color:#cdcd00">const</span> Base<span style="color:#39c">&amp;</span> base) <span style="color:#39c">=</span> <span style="color:#cdcd00">delete</span>; <span style="color:#000080">// 不生成 copy constructor
</span><span style="color:#000080"></span>};
</code></pre></div>
<p>此外由於 C++ 類別中的預設函數生成條件很複雜，可參考 <a href="http://en.cppreference.com/w/cpp/language/rule_of_three">rule of five, rule of zero</a> 等方法決定是否要宣告該預設函式。</p>

<h4 id="new-typedef-語法">New typedef 語法</h4>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#cdcd00">typedef</span> <span style="color:#00cd00">int</span> DefInt;
<span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#cdcd00">using</span> DefInt <span style="color:#39c">=</span> <span style="color:#00cd00">int</span>;
</code></pre></div>
<h2 id="新標準庫">新標準庫</h2>

<h3 id="smart-pointer">Smart Pointer</h3>

<p>C++11 也新增了許多標準函式庫內容。其中一個很重要的是智慧指標（smart point）的支援。過去的 C++ 指標在建立後需手動使用 delete 來刪除該 pointer 否則會出現 memory leak。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++03
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span><span style="color:#39c">*</span> p <span style="color:#39c">=</span> <span style="color:#cdcd00">new</span> <span style="color:#00cd00">int</span>(<span style="color:#cd00cd">3</span>);
<span style="color:#000080">// ... do something
</span><span style="color:#000080"></span><span style="color:#cdcd00">delete</span> p;  <span style="color:#000080">// release memory
</span></code></pre></div>
<p>而 Smart Pointer 則可幫助使用者管理資源且表面行為與指標的物件。以 <code>shared_ptr</code> 來說，真正的 pointer 包裝在該物件中，且可使用與一般 pointer 相同的呼叫方式使用 <code>shared_ptr</code></p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// C++11
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> ptr <span style="color:#39c">=</span> shared_ptr<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>(<span style="color:#cdcd00">new</span> <span style="color:#00cd00">int</span>(<span style="color:#cd00cd">2</span>)); <span style="color:#000080">// Use shared point
</span><span style="color:#000080"></span>cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#39c">*</span>ptr <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl; <span style="color:#000080">// output: 2
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">auto</span> ptr_make <span style="color:#39c">=</span> make_shared<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">42</span>);  <span style="color:#000080">// Use make_shared() function
</span><span style="color:#000080"></span>cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#39c">*</span>ptr_make <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;  <span style="color:#000080">// output: 42
</span></code></pre></div>
<p>此外過去在管理指標時有可能資源已經被 delete，但某些變數仍保有指摽位置，這會導致程式崩潰。而 <code>shared_ptr</code> 內部具有 reference counting 的功能，也就是能記錄有多少個物件被參照到資源，等到都沒有參照到資源時才會執行資源的 delete 動作。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00cd00">void</span> ref(shared_ptr<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span> ptr) {
    <span style="color:#000080">// reference counts = 3 (+1)
</span><span style="color:#000080"></span>    <span style="color:#000080">// do something...
</span><span style="color:#000080"></span>    <span style="color:#000080">// when leave block, reference counts = 2 (-1)
</span><span style="color:#000080"></span>}

<span style="color:#cdcd00">auto</span> pt <span style="color:#39c">=</span> make_shared<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">3</span>);  <span style="color:#000080">// reference count = 1 (+1)
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> pt2 <span style="color:#39c">=</span> pt;  <span style="color:#000080">// reference counts = 2 (+1)
</span><span style="color:#000080"></span>ref(pt);

<span style="color:#000080">// When leaving block
</span><span style="color:#000080"></span><span style="color:#000080">// Call pt2 destructor, reference count = 1 (-1)
</span><span style="color:#000080"></span><span style="color:#000080">// Call pt destructor, reference count = 0 (-1), delete resource.
</span></code></pre></div>
<p>C++11 新增的 Smart point 主要有  <code>shared_ptr</code>，<code>unique_ptr</code> 與 <code>weak_ptr</code>。本節只介紹 shared_ptr 的行為，<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a> 與 <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr">weak_ptr</a> 可自行參考相關資料</p>

<h3 id="concurrency">Concurrency</h3>

<p>由於 C++03 不支援多執行緒功能，因此若要使用多執行緒執行則需要透過 <a href="http://www.openmp.org/">OpenMP</a> 或系統 API 等外部呼叫多執行緒函式。而從 C++11 之後也正式在標準庫中加入多執行緒支援，讓使用者可更簡單的使用。下圖為簡單的使用方式</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">#</span><span style="color:#000080">include</span> <span style="color:#000080">&lt;thread&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#00cd00">void</span> thread_1(<span style="color:#00cd00">int</span> x) {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">call thread_1() : </span><span style="color:#cd0000">&#34;</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}
<span style="color:#00cd00">void</span> thread_2() {
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">Call thread_2()</span><span style="color:#cd0000">&#34;</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;
}

<span style="color:#00cd00">int</span> main(<span style="color:#00cd00">int</span> argc, <span style="color:#00cd00">char</span> <span style="color:#39c">*</span>argv[]) {
    <span style="color:#cdcd00">thread</span> th1(<span style="color:#39c">&amp;</span>thread_1, <span style="color:#cd00cd">3</span>);   <span style="color:#000080">// 建立 thread 物件 th1 並開始執行
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">thread</span> th2(<span style="color:#39c">&amp;</span>thread_2);  <span style="color:#000080">// 建立 thread 物件 th1
</span><span style="color:#000080"></span>
    cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> <span style="color:#cd0000"></span><span style="color:#cd0000">&#34;</span><span style="color:#cd0000">main thread</span><span style="color:#cd0000">&#34;</span> <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;

    th1.join(); <span style="color:#000080">// 一定要加入，宣告 th1() 必須執行完畢後才能往下執行。
</span><span style="color:#000080"></span>    th2.join(); <span style="color:#000080">// 同上
</span><span style="color:#000080"></span>}
</code></pre></div>
<p>當上面的資料執行時，<code>thread_1()</code> 與 <code>thread_2()</code> 可能會有不同的執行順序，或當一邊執行時會切換到另一邊，如下面的執行範例。</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">// Output example - 1
</span><span style="color:#000080"></span>call thread_1() <span style="color:#39c">:</span> Call thread_2()main thread3

<span style="color:#000080">// Output example - 2
</span><span style="color:#000080"></span>main <span style="color:#cdcd00">thread</span>
call thread_1() <span style="color:#39c">:</span> Call thread_2()
<span style="color:#cd00cd">3</span>
</code></pre></div>
<p>可看出因是在不同執行緒中運作，因此執行順序有可能被打亂。而除了上述的基本使用法，其他進階用法可自行參考其他<a href="https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/">資訊</a>。</p>

<h2 id="function-objects">Function Objects</h2>

<p>C++11 新增的 <code>std::function</code> 類別，可以將 function 當作物件般儲存操作與傳遞。而 <code>std::bind</code> 則是能將不同的 function 綁定依照特定順序綁定，重新建立一個函式物件。上面兩類可透過 <code>#include &lt;functional&gt;</code> 引入程式碼中使用。</p>

<h4 id="stdfunction">std::function</h4>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">#</span><span style="color:#000080">include</span> <span style="color:#000080">&lt;functional&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#00cd00">int</span> sumXY(<span style="color:#00cd00">int</span> x, <span style="color:#00cd00">int</span> y) {
    <span style="color:#cdcd00">return</span> x <span style="color:#39c">+</span> y;
}

<span style="color:#000080">// 使用現有函數建立 
</span><span style="color:#000080"></span>std<span style="color:#39c">:</span><span style="color:#39c">:</span>function<span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span>(<span style="color:#00cd00">int</span>,<span style="color:#00cd00">int</span>)<span style="color:#39c">&gt;</span> sum <span style="color:#39c">=</span> sumXY;
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> sum(<span style="color:#cd00cd">1</span>, <span style="color:#cd00cd">3</span>) <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl; <span style="color:#000080">// output: 4
</span><span style="color:#000080"></span>
<span style="color:#000080">// 使用 lambda expression 建立
</span><span style="color:#000080"></span>std<span style="color:#39c">:</span><span style="color:#39c">:</span>function<span style="color:#39c">&lt;</span><span style="color:#00cd00">void</span>(<span style="color:#00cd00">int</span>)<span style="color:#39c">&gt;</span> disp <span style="color:#39c">=</span> [](<span style="color:#00cd00">int</span> x) {cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> x <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;};
disp(<span style="color:#cd00cd">42</span>);  <span style="color:#000080">// output: 42
</span><span style="color:#000080"></span>
<span style="color:#000080">// 使用 auto 自動建立 function object
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> sum_2 <span style="color:#39c">=</span> [](<span style="color:#00cd00">int</span> x, <span style="color:#00cd00">int</span> y) <span style="color:#39c">-</span><span style="color:#39c">&gt;</span> <span style="color:#00cd00">float</span> {<span style="color:#cdcd00">return</span> x <span style="color:#39c">+</span> y <span style="color:#39c">+</span> <span style="color:#cd00cd">1.1</span>; };
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> sum_2(<span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">4</span>) <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl; <span style="color:#000080">// output: 7.1
</span></code></pre></div>
<h4 id="stdbind">std::bind</h4>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000080">#</span><span style="color:#000080">include</span> <span style="color:#000080">&lt;fnuctional&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#00cd00">int</span> mulXY(<span style="color:#00cd00">int</span> x, <span style="color:#00cd00">int</span> y) {
    <span style="color:#cdcd00">return</span> x <span style="color:#39c">*</span> y;
}

<span style="color:#000080">// sum_b(z) = sumXY(8, z)
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> sum_b <span style="color:#39c">=</span> std<span style="color:#39c">:</span><span style="color:#39c">:</span>bind(sumXY, <span style="color:#cd00cd">8</span>, std<span style="color:#39c">:</span><span style="color:#39c">:</span>placeholders<span style="color:#39c">:</span><span style="color:#39c">:</span>_1);
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> sum_b(<span style="color:#cd00cd">10</span>) <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;  <span style="color:#000080">// output: 18
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">using</span> <span style="color:#cdcd00">namespace</span> std<span style="color:#39c">:</span><span style="color:#39c">:</span>placeholders;

<span style="color:#000080">// mul_b(x, y) = mulXY(sumXY(x, y), y)
</span><span style="color:#000080"></span><span style="color:#cdcd00">auto</span> mul_b <span style="color:#39c">=</span> std<span style="color:#39c">:</span><span style="color:#39c">:</span>bind(mulXY, std<span style="color:#39c">:</span><span style="color:#39c">:</span>bind(sumXY, _1, _2), _2);
cout <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> mul_b(<span style="color:#cd00cd">2</span>, <span style="color:#cd00cd">3</span>) <span style="color:#39c">&lt;</span><span style="color:#39c">&lt;</span> endl;    <span style="color:#000080">// output: 15
</span></code></pre></div>
<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/C%2B%2B11">Wikipedia - C++11</a></li>
<li><a href="https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/">Concurrency in C++11</a></li>
</ul>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/c&#43;&#43;/">C&#43;&#43;</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/depthwise-separable-convolution/" data-tooltip="高效卷積計算結構 - Depthwise Separable Convolution">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2018/01/tensorflow-lite-in-ios-device/" data-tooltip="使用 TensorFlow Lite 在 iOS 裝置上進行圖片分類">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2018/02/modern-cpp-changing/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2020 Cheng-Shiang Li. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/depthwise-separable-convolution/" data-tooltip="高效卷積計算結構 - Depthwise Separable Convolution">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/2018/01/tensorflow-lite-in-ios-device/" data-tooltip="使用 TensorFlow Lite 在 iOS 裝置上進行圖片分類">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2018/02/modern-cpp-changing/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=%2F2018%2F02%2Fmodern-cpp-changing%2F">
          <i class="fa fa-twitter"></i><span>Share on Twitter</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="/images/about/me.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Cheng-Shiang Li</h4>
    
      <div id="about-card-bio">Senior software developer. Mastering Android/iOS application development and machine learning algorithm.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Enginner
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Taiwan
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('/images/bg/nasa-space.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = '\/2018\/02\/modern-cpp-changing\/';
          
            this.page.identifier = '\/2018\/02\/modern-cpp-changing\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'yeshuanova';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>




    
  </body>
</html>

